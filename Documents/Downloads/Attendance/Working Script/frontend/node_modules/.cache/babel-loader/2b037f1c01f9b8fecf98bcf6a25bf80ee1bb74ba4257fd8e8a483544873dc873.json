{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\m.hakkim\\\\Documents\\\\Downloads\\\\Attendance\\\\frontend\\\\src\\\\context\\\\NotificationContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport { useAuth } from '../hooks/useAuth';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst NotificationContext = /*#__PURE__*/createContext();\n\n// Initial state with proper default values\nconst initialState = {\n  notifications: [],\n  // Always initialize as empty array\n  unreadCount: 0,\n  loading: false,\n  error: null\n};\n\n// Notification reducer with proper state handling\nconst notificationReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return {\n        ...state,\n        loading: action.payload,\n        error: null\n      };\n    case 'SET_NOTIFICATIONS':\n      // Ensure payload is always an array\n      const notifications = Array.isArray(action.payload) ? action.payload : [];\n      return {\n        ...state,\n        notifications,\n        unreadCount: notifications.filter(n => !n.read).length,\n        loading: false,\n        error: null\n      };\n    case 'ADD_NOTIFICATION':\n      if (!action.payload) return state;\n      const newNotifications = [action.payload, ...(state.notifications || [])];\n      return {\n        ...state,\n        notifications: newNotifications,\n        unreadCount: newNotifications.filter(n => !n.read).length\n      };\n    case 'MARK_AS_READ':\n      if (!action.payload || !Array.isArray(state.notifications)) return state;\n      const updatedNotifications = state.notifications.map(notification => notification._id === action.payload ? {\n        ...notification,\n        read: true\n      } : notification);\n      return {\n        ...state,\n        notifications: updatedNotifications,\n        unreadCount: updatedNotifications.filter(n => !n.read).length\n      };\n    case 'MARK_ALL_AS_READ':\n      if (!Array.isArray(state.notifications)) return state;\n      const allReadNotifications = state.notifications.map(notification => ({\n        ...notification,\n        read: true\n      }));\n      return {\n        ...state,\n        notifications: allReadNotifications,\n        unreadCount: 0\n      };\n    case 'DELETE_NOTIFICATION':\n      if (!action.payload || !Array.isArray(state.notifications)) return state;\n      const filteredNotifications = state.notifications.filter(notification => notification._id !== action.payload);\n      return {\n        ...state,\n        notifications: filteredNotifications,\n        unreadCount: filteredNotifications.filter(n => !n.read).length\n      };\n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload,\n        loading: false\n      };\n    case 'CLEAR_NOTIFICATIONS':\n      return {\n        ...state,\n        notifications: [],\n        unreadCount: 0\n      };\n    default:\n      return state;\n  }\n};\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s();\n  const [state, dispatch] = useReducer(notificationReducer, initialState);\n  const {\n    user,\n    token\n  } = useAuth();\n\n  // Fetch notifications when user is authenticated\n  const fetchNotifications = async () => {\n    if (!user || !token) {\n      dispatch({\n        type: 'CLEAR_NOTIFICATIONS'\n      });\n      return;\n    }\n    try {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: true\n      });\n      const response = await fetch('/api/notifications', {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error('Failed to fetch notifications');\n      }\n      const data = await response.json();\n      dispatch({\n        type: 'SET_NOTIFICATIONS',\n        payload: data.notifications || []\n      });\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      dispatch({\n        type: 'SET_ERROR',\n        payload: error.message\n      });\n      // Set empty array on error to prevent undefined issues\n      dispatch({\n        type: 'SET_NOTIFICATIONS',\n        payload: []\n      });\n    }\n  };\n\n  // Mark notification as read\n  const markAsRead = async notificationId => {\n    if (!notificationId || !token) return;\n    try {\n      const response = await fetch(`/api/notifications/${notificationId}/read`, {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (response.ok) {\n        dispatch({\n          type: 'MARK_AS_READ',\n          payload: notificationId\n        });\n      }\n    } catch (error) {\n      console.error('Error marking notification as read:', error);\n    }\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = async () => {\n    if (!token) return;\n    try {\n      const response = await fetch('/api/notifications/mark-all-read', {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (response.ok) {\n        dispatch({\n          type: 'MARK_ALL_AS_READ'\n        });\n      }\n    } catch (error) {\n      console.error('Error marking all notifications as read:', error);\n    }\n  };\n\n  // Delete notification\n  const deleteNotification = async notificationId => {\n    if (!notificationId || !token) return;\n    try {\n      const response = await fetch(`/api/notifications/${notificationId}`, {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (response.ok) {\n        dispatch({\n          type: 'DELETE_NOTIFICATION',\n          payload: notificationId\n        });\n      }\n    } catch (error) {\n      console.error('Error deleting notification:', error);\n    }\n  };\n\n  // Add new notification (for real-time updates)\n  const addNotification = notification => {\n    if (notification) {\n      dispatch({\n        type: 'ADD_NOTIFICATION',\n        payload: notification\n      });\n    }\n  };\n\n  // Effect to fetch notifications when user changes\n  useEffect(() => {\n    fetchNotifications();\n  }, [user, token]);\n\n  // Set up real-time notification updates (WebSocket or polling)\n  useEffect(() => {\n    if (!user || !token) return;\n\n    // Simple polling for notifications every 30 seconds\n    const interval = setInterval(fetchNotifications, 30000);\n    return () => clearInterval(interval);\n  }, [user, token]);\n  const value = {\n    notifications: state.notifications || [],\n    unreadCount: state.unreadCount || 0,\n    loading: state.loading || false,\n    error: state.error,\n    fetchNotifications,\n    markAsRead,\n    markAllAsRead,\n    deleteNotification,\n    addNotification\n  };\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 232,\n    columnNumber: 5\n  }, this);\n};\n_s(NotificationProvider, \"nuwIjA9W+ueFyLrMqKSk2h+BO3o=\", false, function () {\n  return [useAuth];\n});\n_c = NotificationProvider;\nexport const useNotifications = () => {\n  _s2();\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n_s2(useNotifications, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default NotificationContext;\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","useAuth","jsxDEV","_jsxDEV","NotificationContext","initialState","notifications","unreadCount","loading","error","notificationReducer","state","action","type","payload","Array","isArray","filter","n","read","length","newNotifications","updatedNotifications","map","notification","_id","allReadNotifications","filteredNotifications","NotificationProvider","children","_s","dispatch","user","token","fetchNotifications","response","fetch","headers","ok","Error","data","json","console","message","markAsRead","notificationId","method","markAllAsRead","deleteNotification","addNotification","interval","setInterval","clearInterval","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useNotifications","_s2","context","$RefreshReg$"],"sources":["C:/Users/m.hakkim/Documents/Downloads/Attendance/frontend/src/context/NotificationContext.js"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport { useAuth } from '../hooks/useAuth';\n\nconst NotificationContext = createContext();\n\n// Initial state with proper default values\nconst initialState = {\n  notifications: [], // Always initialize as empty array\n  unreadCount: 0,\n  loading: false,\n  error: null\n};\n\n// Notification reducer with proper state handling\nconst notificationReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return {\n        ...state,\n        loading: action.payload,\n        error: null\n      };\n\n    case 'SET_NOTIFICATIONS':\n      // Ensure payload is always an array\n      const notifications = Array.isArray(action.payload) ? action.payload : [];\n      return {\n        ...state,\n        notifications,\n        unreadCount: notifications.filter(n => !n.read).length,\n        loading: false,\n        error: null\n      };\n\n    case 'ADD_NOTIFICATION':\n      if (!action.payload) return state;\n      const newNotifications = [action.payload, ...(state.notifications || [])];\n      return {\n        ...state,\n        notifications: newNotifications,\n        unreadCount: newNotifications.filter(n => !n.read).length\n      };\n\n    case 'MARK_AS_READ':\n      if (!action.payload || !Array.isArray(state.notifications)) return state;\n      const updatedNotifications = state.notifications.map(notification =>\n        notification._id === action.payload\n          ? { ...notification, read: true }\n          : notification\n      );\n      return {\n        ...state,\n        notifications: updatedNotifications,\n        unreadCount: updatedNotifications.filter(n => !n.read).length\n      };\n\n    case 'MARK_ALL_AS_READ':\n      if (!Array.isArray(state.notifications)) return state;\n      const allReadNotifications = state.notifications.map(notification => ({\n        ...notification,\n        read: true\n      }));\n      return {\n        ...state,\n        notifications: allReadNotifications,\n        unreadCount: 0\n      };\n\n    case 'DELETE_NOTIFICATION':\n      if (!action.payload || !Array.isArray(state.notifications)) return state;\n      const filteredNotifications = state.notifications.filter(\n        notification => notification._id !== action.payload\n      );\n      return {\n        ...state,\n        notifications: filteredNotifications,\n        unreadCount: filteredNotifications.filter(n => !n.read).length\n      };\n\n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload,\n        loading: false\n      };\n\n    case 'CLEAR_NOTIFICATIONS':\n      return {\n        ...state,\n        notifications: [],\n        unreadCount: 0\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport const NotificationProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(notificationReducer, initialState);\n  const { user, token } = useAuth();\n\n  // Fetch notifications when user is authenticated\n  const fetchNotifications = async () => {\n    if (!user || !token) {\n      dispatch({ type: 'CLEAR_NOTIFICATIONS' });\n      return;\n    }\n\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      \n      const response = await fetch('/api/notifications', {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to fetch notifications');\n      }\n\n      const data = await response.json();\n      dispatch({ type: 'SET_NOTIFICATIONS', payload: data.notifications || [] });\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      dispatch({ type: 'SET_ERROR', payload: error.message });\n      // Set empty array on error to prevent undefined issues\n      dispatch({ type: 'SET_NOTIFICATIONS', payload: [] });\n    }\n  };\n\n  // Mark notification as read\n  const markAsRead = async (notificationId) => {\n    if (!notificationId || !token) return;\n\n    try {\n      const response = await fetch(`/api/notifications/${notificationId}/read`, {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      if (response.ok) {\n        dispatch({ type: 'MARK_AS_READ', payload: notificationId });\n      }\n    } catch (error) {\n      console.error('Error marking notification as read:', error);\n    }\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = async () => {\n    if (!token) return;\n\n    try {\n      const response = await fetch('/api/notifications/mark-all-read', {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      if (response.ok) {\n        dispatch({ type: 'MARK_ALL_AS_READ' });\n      }\n    } catch (error) {\n      console.error('Error marking all notifications as read:', error);\n    }\n  };\n\n  // Delete notification\n  const deleteNotification = async (notificationId) => {\n    if (!notificationId || !token) return;\n\n    try {\n      const response = await fetch(`/api/notifications/${notificationId}`, {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      if (response.ok) {\n        dispatch({ type: 'DELETE_NOTIFICATION', payload: notificationId });\n      }\n    } catch (error) {\n      console.error('Error deleting notification:', error);\n    }\n  };\n\n  // Add new notification (for real-time updates)\n  const addNotification = (notification) => {\n    if (notification) {\n      dispatch({ type: 'ADD_NOTIFICATION', payload: notification });\n    }\n  };\n\n  // Effect to fetch notifications when user changes\n  useEffect(() => {\n    fetchNotifications();\n  }, [user, token]);\n\n  // Set up real-time notification updates (WebSocket or polling)\n  useEffect(() => {\n    if (!user || !token) return;\n\n    // Simple polling for notifications every 30 seconds\n    const interval = setInterval(fetchNotifications, 30000);\n\n    return () => clearInterval(interval);\n  }, [user, token]);\n\n  const value = {\n    notifications: state.notifications || [],\n    unreadCount: state.unreadCount || 0,\n    loading: state.loading || false,\n    error: state.error,\n    fetchNotifications,\n    markAsRead,\n    markAllAsRead,\n    deleteNotification,\n    addNotification\n  };\n\n  return (\n    <NotificationContext.Provider value={value}>\n      {children}\n    </NotificationContext.Provider>\n  );\n};\n\nexport const useNotifications = () => {\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n\nexport default NotificationContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}